from clinica.engine.cworkflow import *


def dwi_preprocessing_special_adni(base_directory, subject_id, working_directory, num_b0s, datasink_directory):
    """
    Create and run a high level pipeline to preprocess the DWI Images :
        - Preparation of the dataset
        - Correction for Head Motion
        - Correction for Eddy Currents
        - Correction for EPI susceptibility induced distortions using the SyN algorithm (SyB)
        - Bias field correction
    The outputs presented are typically outputs necessary for further tractography.

    Inputs
    ---------
    in_dwi : STRING
      Path to the DWI image.
    in_T1: STRING
      Path to the T1 image.
    in_bvals: STRING
      Path to the b-vals text file.
    in_bvecs: STRING
      Path to the b-vecs text file.
    working_directory : STRING
      Directory to use as tmp for all the temporary files generated by the workflow.
    num_b0s : INT
      Number of B0 images.
    datasink_directory : STRING
      Base directory of the datasink.

    Outputs
    ----------
        DWI_hmc_ecc_sdc_bias_corrected - DWI corrected for Head motion, Eddy currents, EPI susceptibility induced distortions (syb) and bias field
        out_bvecs - updated and corrected gradient vectors table
        out_bvals - updated gradient values table
        mask_b0 - Binary mask obtained from the average of the B0 images

    """

    import nipype.interfaces.io as nio
    import nipype.interfaces.utility as niu
    import nipype.pipeline.engine as pe
    import os.path as op
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import prepare_data
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import ecc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import hmc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import sdc_syb_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import apply_all_corrections_syb
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import remove_bias

# Inputs existence checking

    inputs=[base_directory, subject_id, working_directory, datasink_directory]

    for input_file in inputs:
        if not op.exists(input_file):
            raise IOError('file {} does not exist'.format(input_file))

    datasource = pe.Node(interface=nio.DataGrabber(
                         infields=['subject_id'],
                         outfields=['dwi', 'bvecs', 'bvals', 'T1']),
                         name='datasource')
    datasource.inputs.base_directory = base_directory
    datasource.inputs.template = '*'
    datasource.inputs.field_template = dict(dwi='%s/A*/*/S*/*.nii',
                                            bvals='/aramis/home/jacquemont/DataAramis/ADNI_Data/Raw_data/b_vals_41.txt',
                                            bvecs='/aramis/home/jacquemont/DataAramis/ADNI_Data/Raw_data/b_vecs_41.txt',
                                            T1='%s/S*/*/S*/*.nii')
    datasource.inputs.template_args = dict(dwi=[['subject_id']],
                                           bvals=[[]],
                                           bvecs=[[]],
                                           T1=[['subject_id']])
    datasource.inputs.sort_filelist = True


    inputnode = pe.Node(interface=niu.IdentityInterface(fields=["dwi_image", "bvectors_directions", "bvalues", 'T1_image']), name="inputnode")

    pre = prepare_data(datasink_directory=datasink_directory, num_b0s=num_b0s)

    hmc = hmc_pipeline(datasink_directory)

    ecc = ecc_pipeline(datasink_directory)

    sdc = sdc_syb_pipeline(datasink_directory)

    bias = remove_bias()

    aac = apply_all_corrections_syb(datasink_directory)

    datasink = pe.Node(nio.DataSink(), name='datasink_tracto')
    datasink.inputs.base_directory = op.join(datasink_directory, 'Outputs_for_Tractography/')

    wf = pe.Workflow(name='preprocess',base_dir=datasink_directory)
    wf.base_dir = working_directory

    wf.connect([(datasource, inputnode, [('dwi_image','dwi_image'), ('bvalues','bvalues'), ('bvectors_directions','bvectors_directions'), ('T1_image','T1_image')])])
    wf.connect([(inputnode, pre, [('dwi_image', 'inputnode.in_file'),
                                  ('bvalues', 'inputnode.in_bvals'),
                                  ('bvectors_directions', 'inputnode.in_bvecs')])])
    wf.connect([(pre, hmc,[('outputnode.dwi_b0_merge','inputnode.in_file'), ('outputnode.out_bvals','inputnode.in_bval'), ('outputnode.out_bvecs','inputnode.in_bvec')])])
    wf.connect([(pre, hmc, [('outputnode.mask_b0','inputnode.in_mask')])])
    wf.connect([(hmc, ecc, [('outputnode.out_xfms','inputnode.in_xfms'),('outputnode.out_file','inputnode.in_file')])])
    wf.connect([(pre, ecc, [('outputnode.out_bvals','inputnode.in_bval')])])
    wf.connect([(pre, ecc, [('outputnode.mask_b0','inputnode.in_mask')])])
    wf.connect([(ecc, sdc, [('outputnode.out_file','inputnode.DWI')])])
    wf.connect([(inputnode, sdc, [('T1_image','inputnode.T1')])])
    wf.connect([(pre, aac, [('outputnode.dwi_b0_merge', 'inputnode.in_dwi')])])
    wf.connect([(hmc, aac, [('outputnode.out_xfms', 'inputnode.in_hmc')])])
    wf.connect([(ecc, aac, [('outputnode.out_xfms', 'inputnode.in_ecc')])])
    wf.connect([(sdc, aac, [('outputnode.out_warp', 'inputnode.in_sdc_syb')])])
    wf.connect([(inputnode, aac, [('T1_image','inputnode.T1')])])

    wf.connect([(aac, bias, [('outputnode.out_file','inputnode.in_file')])])

    wf.connect([(bias, datasink, [('outputnode.out_file','DWI_hmc_ecc_sdc_bias_corrected')])])
    wf.connect([(hmc, datasink, [('outputnode.out_bvec','out_bvecs')])])
    wf.connect([(pre, datasink, [('outputnode.out_bvals','out_bvals')])])
    wf.connect([(bias, datasink, [('outputnode.b0_mask','b0_mask')])])

    return wf

