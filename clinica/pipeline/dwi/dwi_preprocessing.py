#!/usr/bin/python


#def create_dwi_preproc_syb(in_dwi, in_t1, in_bvals, in_bvecs, working_directory, num_b0s, datasink_directory):
#    """
#    create and run a high level pipeline to preprocess the dwi images :
#        - preparation of the dataset
#        - correction for head motion
#        - correction for eddy currents
#        - correction for epi susceptibility induced distortions using the syn algorithm (syb) from ants
#        - bias field correction
#    the outputs presented are typically outputs necessary for further tractography.
#
#    inputs
#    ---------
#    in_dwi : string
#      path to the dwi image.
#    in_t1: string
#      path to the t1 image.
#    in_bvals: string
#      path to the b-vals text file.
#    in_bvecs: string
#      path to the b-vecs text file.
#    working_directory : string
#      directory to use as tmp for all the temporary files generated by the workflow.
#    num_b0s : int
#      number of b0 images.
#    datasink_directory : string
#      base directory of the datasink.
#
#    outputs
#    ----------
#        dwi_hmc_ecc_sdc_bias_corrected - dwi corrected for head motion, eddy currents, epi susceptibility induced distortions (syb) and bias field
#        out_bvecs - updated and corrected gradient vectors table
#        out_bvals - updated gradient values table
#        mask_b0 - binary mask obtained from the average of the b0 images
#
#    """
#
#    import nipype.interfaces.io as nio
#    import nipype.interfaces.utility as niu
#    import nipype.pipeline.engine as pe
#    import os.path as op
#    from clinica.pipeline.dwi.dwi_preprocessing_workflows import prepare_data
#    from clinica.pipeline.dwi.dwi_preprocessing_workflows import ecc_pipeline
#    from clinica.pipeline.dwi.dwi_preprocessing_workflows import hmc_pipeline
#    from clinica.pipeline.dwi.dwi_preprocessing_workflows import sdc_syb_pipeline
#    from clinica.pipeline.dwi.dwi_preprocessing_workflows import apply_all_corrections_syb
#    from clinica.pipeline.dwi.dwi_preprocessing_workflows import remove_bias
#
## inputs existence checking
#
#    inputs=[in_dwi, in_t1, in_bvals, in_bvecs, working_directory, datasink_directory]
#
#    for input_file in inputs:
#        if not op.exists(input_file):
#            raise ioerror('file {} does not exist'.format(input_file))
#
#    datasource = pe.Node(interface=nio.datagrabber(infields=[], outfields=['dwi_image','bvectors_directions','bvalues','t1_image']), name='datasource')
#    datasource.inputs.template = '*'
#    datasource.inputs.field_template = dict(dwi_image= in_dwi,
#                                            bvalues=in_bvals,
#                                            bvectors_directions= in_bvecs,
#                                            t1_image= in_t1)
#    datasource.inputs.template_args = dict(dwi_image=[[]],
#                                           bvalues=[[]],
#                                           bvectors_directions=[[]],
#                                           t1_image=[[]])
#    datasource.inputs.sort_filelist = True
#
#    inputnode = pe.Node(interface=niu.IdentityInterface(
#        fields=["dwi_image", "bvectors_directions", "bvalues", 't1_image']), name="inputnode")
#
#    pre = prepare_data(num_b0s=num_b0s)
#    hmc = hmc_pipeline()
#    ecc = ecc_pipeline()
#    sdc = sdc_syb_pipeline(datasink_directory=datasink_directory)
#    bias = remove_bias()
#    aac = apply_all_corrections_syb(datasink_directory)
#
#    datasink = pe.Node(nio.datasink(), name='datasink_tracto')
#    datasink.inputs.base_directory = op.join(datasink_directory, 'outputs_for_tractography/')
#
#    wf = pe.Workflow(name='preprocess',base_dir=working_directory)
#    wf.connect([
#        (datasource, inputnode, [('dwi_image','dwi_image'),
#                                 ('bvalues','bvalues'),
#                                 ('bvectors_directions','bvectors_directions'),
#                                 ('t1_image','t1_image')]),
#        (inputnode, pre, [('dwi_image', 'inputnode.in_file'),
#                          ('bvalues', 'inputnode.in_bvals'),
#                          ('bvectors_directions', 'inputnode.in_bvecs')]),
#        (pre, hmc, [('outputnode.dwi_b0_merge','inputnode.in_file'),
#                    ('outputnode.out_bvals','inputnode.in_bval'),
#                    ('outputnode.out_bvecs','inputnode.in_bvec'),
#                    ('outputnode.mask_b0','inputnode.in_mask')]),
#        (hmc, ecc, [('outputnode.out_xfms','inputnode.in_xfms'),
#                    ('outputnode.out_file','inputnode.in_file')]),
#        (pre, ecc, [('outputnode.out_bvals','inputnode.in_bval')]),
#        (pre, ecc, [('outputnode.mask_b0','inputnode.in_mask')]),
#        (ecc, sdc, [('outputnode.out_file','inputnode.dwi')]),
#        (inputnode, sdc, [('t1_image','inputnode.t1')]),
#        (pre,       aac, [('outputnode.dwi_b0_merge', 'inputnode.in_dwi')]),
#        (hmc,       aac, [('outputnode.out_xfms', 'inputnode.in_hmc')]),
#        (ecc,       aac, [('outputnode.out_xfms', 'inputnode.in_ecc')]),
#        (sdc,       aac, [('outputnode.out_warp', 'inputnode.in_sdc_syb')]),
#        (inputnode, aac, [('t1_image','inputnode.t1')]),
#        (aac, bias, [('outputnode.out_file','inputnode.in_file')]),
#        (bias, datasink, [('outputnode.out_file','dwi_hmc_ecc_sdc_bias_corrected')]),
#        (hmc,  datasink, [('outputnode.out_bvec','out_bvecs')]),
#        (pre,  datasink, [('outputnode.out_bvals','out_bvals')]),
#        (bias, datasink, [('outputnode.b0_mask','b0_mask')])
#    ])
#
#    return wf


def diffusion_preprocessing_t1_based(participant_id, session_id, caps_directory,
                                     num_b0s, working_directory=None,
                                     name='diffusion_preprocessing_t1_based'):
    """
    create and run a high level pipeline to preprocess the dwi images :
        - preparation of the dataset
        - correction for head motion
        - correction for eddy currents
        - correction for epi susceptibility induced distortions using the syn algorithm (syb) from ants
        - bias field correction
    the outputs presented are typically outputs necessary for further tractography.

    inputs
    ---------
    in_dwi : string
      path to the dwi image.
    in_t1: string
      path to the t1 image.
    in_bvals: string
      path to the b-vals text file.
    in_bvecs: string
      path to the b-vecs text file.
    working_directory : string
      directory to use as tmp for all the temporary files generated by the workflow.
    num_b0s : int
      number of b0 images.
    datasink_directory : string
      base directory of the datasink.

    outputs
    ----------
        dwi_hmc_ecc_sdc_bias_corrected - dwi corrected for head motion, eddy currents, epi susceptibility induced distortions (syb) and bias field
        out_bvecs - updated and corrected gradient vectors table
        out_bvals - updated gradient values table
        mask_b0 - binary mask obtained from the average of the b0 images

    """

    import nipype.interfaces.io as nio
    import nipype.interfaces.utility as niu
    import nipype.pipeline.engine as pe
    import os.path as op
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import prepare_data
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import ecc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import hmc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import sdc_syb_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import apply_all_corrections_syb
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import remove_bias
    from clinica.utils.check_dependency import check_ants, check_fsl

    check_ants(); check_fsl()

    inputnode = pe.Node(niu.IdentityInterface(
        fields=['in_dwi', 'in_bvals', 'in_bvecs', 'in_t1']),
        name='inputnode')

    pre = prepare_data(num_b0s=num_b0s)
    hmc = hmc_pipeline()
    ecc = ecc_pipeline()
    sdc = sdc_syb_pipeline()
    bias = remove_bias()
    aac = apply_all_corrections_syb()

    datasink = pe.Node(nio.DataSink(), name='datasink')
    caps_identifier = participant_id + '_' + session_id
    datasink.inputs.base_directory = op.join(
        caps_directory, 'subjects', participant_id, session_id, 'dwi')
    datasink.inputs.substitutions = [('vol0000_warp_maths_thresh_merged_roi_brain_mask.nii.gz', caps_identifier + '_b0Mask.nii.gz'),
                                     ('vol0000_maths_thresh_merged.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('bvecs_rotated.bvec', caps_identifier + '_dwi.bvec'),
                                     ('bvals', caps_identifier + '_dwi.bval'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('vol0', caps_identifier + '_hmc-dwi-0'),
                                     ('_flirt.mat', '.mat')
                                     ]

    wf = pe.Workflow(name=name, base_dir=working_directory)
    wf.connect([
        # Preliminary step (computation of a mean b0):
        (inputnode, pre, [('in_dwi', 'inputnode.in_file'),
                          ('in_bvals', 'inputnode.in_bvals'),
                          ('in_bvecs', 'inputnode.in_bvecs')]),
        # Head-motion correction:
        (pre, hmc, [('outputnode.dwi_b0_merge','inputnode.in_file'),
                    ('outputnode.out_bvals','inputnode.in_bval'),
                    ('outputnode.out_bvecs','inputnode.in_bvec'),
                    ('outputnode.mask_b0','inputnode.in_mask')]),
        # Eddy-current correction:
        (hmc, ecc, [('outputnode.out_xfms','inputnode.in_xfms'),
                    ('outputnode.out_file','inputnode.in_file')]),
        (pre, ecc, [('outputnode.out_bvals','inputnode.in_bval'),
                    ('outputnode.mask_b0','inputnode.in_mask')]),
        # Magnetic susceptibility correction:
        (ecc,       sdc, [('outputnode.out_file','inputnode.in_dwi')]),
        (inputnode, sdc, [('in_t1','inputnode.in_t1')]),
        # Apply all corrections:
        (pre,       aac, [('outputnode.dwi_b0_merge', 'inputnode.in_dwi')]),
        (hmc,       aac, [('outputnode.out_xfms', 'inputnode.in_hmc')]),
        (ecc,       aac, [('outputnode.out_xfms', 'inputnode.in_ecc')]),
        (sdc,       aac, [('outputnode.out_warp', 'inputnode.in_sdc_syb')]),
        (inputnode, aac, [('in_t1','inputnode.in_t1')]),
        # Bias correction:
        (aac, bias, [('outputnode.out_file','inputnode.in_file')]),
        # Datasink:
        (bias, datasink, [('outputnode.out_file','preprocessing.@out_preprocessed_dwi')]),
        (hmc,  datasink, [('outputnode.out_bvec','preprocessing.@out_bvecs')]),
        (pre,  datasink, [('outputnode.out_bvals','preprocessing.@out_bvals')]),
        (bias, datasink, [('outputnode.b0_mask','preprocessing.@out_b0_mask')])
    ])

    return wf



def diffusion_preprocessing_phasediff_fieldmap(
        participant_id, session_id,
        caps_directory, num_b0s,
        delta_echo_time=None, effective_echo_spacing=None, phase_encoding_direction=None,
        register_fmap_on_b0=True,
        working_directory=None,
        name='diffusion_preprocessing_phasediff_fieldmap'):
    """
    first extract the b0 volumes, co-registration and mean of the b0 volumes.
    see :func:`dwi_utils.b0_dwi_split`, :func:`dwi_utils.b0_flirt_pipeline`, :func:`dwi_utils.b0_average`.

    then, correct four types of bias from epi :
     - head motion correction. see :func:`dwi_corrections.hmc_pipeline`.
     - susceptibility bias correction. see :func:`dwi_corrections.sdc_fmb`.
     - eddy current correction. see :func:`dwi_corrections.ecc_pipeline`.
     - estimates a single multiplicative bias field from the
    averaged *b0* image and applies it onto the diffusion data set. see :func:`dwi_corrections.remove_bias`.

    inputnode
    ----------
    in_dwi : file
      mandatory input. dwi data set to preprocess.
    in_bvals : file
      mandatory input. bval file.
    in_bvecs : file
      mandatory input. bvecs file.
    bmap_mag : file
      mandatory input. grefield map. magnitude.
    bmap_pha : file
      mandatory input. grefield map. phase.

    outputnode
    ----------
    out_file : file
      output. the set of b0 volumes.
    out_bvec : file
      output. the bvecs corresponding to the out_dwi.
    out_bval : file
      output. the bvalues corresponding to the out_dwi.
    out_mask : file
      output : the binary mask file.

    """
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import hmc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import sdc_fmb
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import ecc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import remove_bias
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import prepare_data
    from nipype.workflows.dmri.fsl.utils import apply_all_corrections
    import nipype.interfaces.io as nio
    import nipype.interfaces.utility as niu
    import nipype.pipeline.engine as pe
    import os.path as op
    from clinica.utils.check_dependency import check_ants, check_fsl

    check_ants(); check_fsl()

    if delta_echo_time is None:
        raise ValueError('Invalid value for the difference of echo time.')
    if effective_echo_spacing is None:
        raise ValueError('Invalid value for the effective echo spacing parameter.')
    if phase_encoding_direction is None:
        raise ValueError('Invalid value for the phase encoding direction.')

    inputnode = pe.Node(niu.IdentityInterface(
        fields=['in_dwi', 'in_bvals', 'in_bvecs', 'in_fmap_magnitude', 'in_fmap_phasediff']),
        name='inputnode')

    hmc = hmc_pipeline(name='HeadMotionCorrection')
    hmc.inputs.inputnode.ref_num = 0
    sdc = sdc_fmb(name='EPICorrectionWithPhaseDiffFmap',
                  fugue_params=dict(smooth3d=2.0),
                  fmap_params=dict(delta_te=delta_echo_time),
                  epi_params=dict(echospacing=effective_echo_spacing,
                  enc_dir=phase_encoding_direction,
                  register_fmap_on_b0=register_fmap_on_b0)
                  )
    ecc = ecc_pipeline(name='EddyCurrentCorrection')
    pre = prepare_data(num_b0s=num_b0s)
    unwarp = apply_all_corrections(name='ApplyAllCorrections')

    bias = remove_bias(name='RemoveBias')

    outputnode = pe.Node(niu.IdentityInterface(
        fields=['out_preprocessed_dwi', 'out_bvecs', 'out_bvals',  'out_b0_mask']),
        name='outputnode')

    datasink = pe.Node(nio.DataSink(), name='datasink')
    caps_identifier = participant_id + '_' + session_id
    datasink.inputs.base_directory = op.join(caps_directory, 'subjects', participant_id, session_id, 'dwi')
    datasink.inputs.substitutions = [('vol0000_warp_maths_thresh_merged_roi_brain_mask.nii.gz', caps_identifier + '_b0Mask.nii.gz'),
                                     ('vol0000_maths_thresh_merged.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('bvecs_rotated.bvec', caps_identifier + '_dwi.bvec'),
                                     ('bvals', caps_identifier + '_dwi.bval'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('vol0000_unwarped_thresh_merged.nii.gz', caps_identifier + '_unwarped_thresh_merged.nii.gz'),
                                     ('vol0000_unwarped_thresh_merged_concatwarp.nii.gz', caps_identifier + '_unwarped_thresh_merged_concatwarp.nii.gz'),
                                     ('vol0', caps_identifier + '_hmc-dwi-0'),
                                     ('_flirt.mat', '.mat')
                                     ]
#    datasink.inputs.regexp_substitutions = [('vol\d_flirt.mat', caps_identifier + '_hmc-dwi-\d{1,3}.mat')]

    wf = pe.Workflow(name=name, base_dir=working_directory)
    wf.connect([
        # Preliminary step (computation of a mean b0):
        (inputnode, pre, [('in_dwi', 'inputnode.in_file'),
                          ('in_bvals', 'inputnode.in_bvals'),
                          ('in_bvecs', 'inputnode.in_bvecs')]),
        # Head-motion correction:
        (pre, hmc, [('outputnode.dwi_b0_merge', 'inputnode.in_file'),
                    ('outputnode.out_bvals', 'inputnode.in_bval'),
                    ('outputnode.out_bvecs', 'inputnode.in_bvec')]),
        (pre, hmc, [('outputnode.mask_b0', 'inputnode.in_mask')]),
        # Susceptibility distortion correction:
        (hmc,       sdc, [('outputnode.out_file', 'inputnode.in_file')]),
        (pre,       sdc, [('outputnode.mask_b0', 'inputnode.in_mask')]),
        (inputnode, sdc, [('in_fmap_magnitude', 'inputnode.in_fmap_magnitude')]),
        (inputnode, sdc, [('in_fmap_phasediff', 'inputnode.in_fmap_phasediff')]),
        # Eddy-currents correction:
        (hmc, ecc, [('outputnode.out_xfms', 'inputnode.in_xfms')]),
        (pre, ecc, [('outputnode.out_bvals', 'inputnode.in_bval')]),
        (sdc, ecc, [('outputnode.out_file', 'inputnode.in_file')]),
        (pre, ecc, [('outputnode.mask_b0', 'inputnode.in_mask')]),
        # Apply all corrections:
        (pre, unwarp, [('outputnode.dwi_b0_merge', 'inputnode.in_dwi')]),
        (hmc, unwarp, [('outputnode.out_xfms', 'inputnode.in_hmc')]),
        (ecc, unwarp, [('outputnode.out_xfms', 'inputnode.in_ecc')]),
        (sdc, unwarp, [('outputnode.out_warp', 'inputnode.in_sdc')]),
        # Remove bias:
        (unwarp, bias, [('outputnode.out_file', 'inputnode.in_file')]),
#        (mask_b0,   bias, [('mask_file', 'inputnode.in_mask')]),
        # Outputnode:
        (hmc,  outputnode, [('outputnode.out_bvec', 'out_bvecs')]),
        (pre,  outputnode, [('outputnode.out_bvals', 'out_bvals')]),
        (bias, outputnode, [('outputnode.out_file', 'out_preprocessed_dwi')]),
        (bias, outputnode, [('outputnode.b0_mask','out_b0_mask')]),
        # Datasink:
        (hmc,  datasink, [('outputnode.out_xfms', 'preprocessing.head-motion-correction.@out_matrices')]),
        (pre,  datasink, [('outputnode.out_bvals', 'preprocessing.head-motion-correction.@out_bval')]),
        (hmc,  datasink, [('outputnode.out_bvec', 'preprocessing.head-motion-correction.@out_bvec')]),
        (hmc,  datasink, [('outputnode.out_file', 'preprocessing.head-motion-correction.@out_file')]),
        (ecc,  datasink, [('outputnode.out_file', 'preprocessing.eddy-currents-correction.@out_file')]),
        (sdc,  datasink, [('outputnode.out_file', 'preprocessing.susceptibility-distortion-correction.@out_file')]),
        (sdc,  datasink, [('outputnode.out_vsm', 'preprocessing.susceptibility-distortion-correction.@out_vsm')]),
        (sdc,  datasink, [('outputnode.out_warp', 'preprocessing.susceptibility-distortion-correction.@out_warp')]),
        (sdc,  datasink, [('outputnode.out_registered_fmap', 'preprocessing.susceptibility-distortion-correction.@out_registered_fmap')]),
        (pre,  datasink, [('outputnode.out_bvals', 'preprocessing.@out_bvals')]),
        (hmc,  datasink, [('outputnode.out_bvec', 'preprocessing.@out_bvecs')]),
        (bias, datasink, [('outputnode.b0_mask','preprocessing.@out_b0_mask')]),
        (bias, datasink, [('outputnode.out_file', 'preprocessing.@out_preprocessed_dwi')])
        ])

    return wf



def diffusion_preprocessing_twophase_fieldmap(
        participant_id, session_id,
        caps_directory, num_b0s,
        delta_echo_time=None, effective_echo_spacing=None, phase_encoding_direction=None,
        working_directory=None,
        name='diffusion_preprocessing_twophase_fieldmap'):
    """
    first extract the b0 volumes, co-registration and mean of the b0 volumes.
    see :func:`dwi_utils.b0_dwi_split`, :func:`dwi_utils.b0_flirt_pipeline`, :func:`dwi_utils.b0_average`.

    then, correct four types of bias from epi :
     - head motion correction. see :func:`dwi_corrections.hmc_pipeline`.
     - susceptibility bias correction. see :func:`dwi_corrections.sdc_fmb`.
     - eddy current correction. see :func:`dwi_corrections.ecc_pipeline`.
     - estimates a single multiplicative bias field from the
    averaged *b0* image and applies it onto the diffusion data set. see :func:`dwi_corrections.remove_bias`.

    inputnode
    ----------
    in_dwi : file
      mandatory input. dwi data set to preprocess.
    in_bvals : file
      mandatory input. bval file.
    in_bvecs : file
      mandatory input. bvecs file.
    bmap_mag : file
      mandatory input. grefield map. magnitude.
    bmap_pha : file
      mandatory input. grefield map. phase.

    outputnode
    ----------
    out_file : file
      output. the set of b0 volumes.
    out_bvec : file
      output. the bvecs corresponding to the out_dwi.
    out_bval : file
      output. the bvalues corresponding to the out_dwi.
    out_mask : file
      output : the binary mask file.

    """
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import hmc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import sdc_fmb_twophase
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import ecc_pipeline
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import remove_bias
    from clinica.pipeline.dwi.dwi_preprocessing_workflows import prepare_data
    from nipype.workflows.dmri.fsl.utils import apply_all_corrections
    import nipype.interfaces.io as nio
    import nipype.interfaces.utility as niu
    import nipype.pipeline.engine as pe
    import os.path as op
    from clinica.utils.check_dependency import check_ants, check_fsl

    check_ants(); check_fsl()

    if delta_echo_time is None:
        raise ValueError('Invalid value for the difference of echo time.')
    if effective_echo_spacing is None:
        raise ValueError('Invalid value for the effective echo spacing parameter.')
    if phase_encoding_direction is None:
        raise ValueError('Invalid value for the phase encoding direction.')

    inputnode = pe.Node(niu.IdentityInterface(
        fields=['in_dwi', 'in_bvals', 'in_bvecs',
                'in_fmap_magnitude1', 'in_fmap_phase1', 'in_fmap_magnitude2', 'in_fmap_phase2']),
        name='inputnode')

    bias = remove_bias(name='RemoveBias')
    hmc = hmc_pipeline(name='HeadMotionCorrection')
    hmc.inputs.inputnode.ref_num = 0
    sdc = sdc_fmb_twophase(name='EPICorrectionWithTwoPhaseFmap',
                  fugue_params=dict(smooth3d=2.0),
                  fmap_params=dict(delta_te=delta_echo_time),
                  epi_params=dict(echospacing=effective_echo_spacing,
                  enc_dir=phase_encoding_direction)
                  )
    ecc = ecc_pipeline(name='EddyCurrentCorrection')
    pre = prepare_data(num_b0s=num_b0s)
    unwarp = apply_all_corrections(name="ApplyAllCorrections")

    outputnode = pe.Node(niu.IdentityInterface(
        fields=['out_preprocessed_dwi', 'out_bvecs', 'out_bvals',  'out_b0_mask']),
        name='outputnode')

    datasink = pe.Node(nio.DataSink(), name='datasink')
    caps_identifier = participant_id + '_' + session_id
    datasink.inputs.base_directory = op.join(caps_directory, 'subjects', participant_id, session_id, 'dwi')
    datasink.inputs.substitutions = [('vol0000_warp_maths_thresh_merged_roi_brain_mask.nii.gz', caps_identifier + '_b0Mask.nii.gz'),
                                     ('vol0000_maths_thresh_merged.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('bvecs_rotated.bvec', caps_identifier + '_dwi.bvec'),
                                     ('bvals', caps_identifier + '_dwi.bval'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('merged_files.nii.gz', caps_identifier + '_dwi.nii.gz'),
                                     ('vol0000_unwarped_thresh_merged.nii.gz', caps_identifier + '_unwarped_thresh_merged.nii.gz'),
                                     ('vol0000_unwarped_thresh_merged_concatwarp.nii.gz', caps_identifier + '_unwarped_thresh_merged_concatwarp.nii.gz'),
                                     ('vol0', caps_identifier + '_hmc-dwi-0'),
                                     ('_flirt.mat', '.mat')
                                     ]
#    datasink.inputs.regexp_substitutions = [('vol\d_flirt.mat', caps_identifier + '_hmc-dwi-\d{1,3}.mat')]

    wf = pe.Workflow(name=name, base_dir=working_directory)
    wf.connect([
        # Preliminary step (computation of a mean b0):
        (inputnode, pre, [('in_dwi', 'inputnode.in_file'),
                          ('in_bvals', 'inputnode.in_bvals'),
                          ('in_bvecs', 'inputnode.in_bvecs')]),
        # Head-motion correction:
        (pre, hmc, [('outputnode.dwi_b0_merge', 'inputnode.in_file'),
                    ('outputnode.out_bvals', 'inputnode.in_bval'),
                    ('outputnode.out_bvecs', 'inputnode.in_bvec')]),
        (pre, hmc, [('outputnode.mask_b0', 'inputnode.in_mask')]),
        # Susceptibility distortion correction:
        (hmc,       sdc, [('outputnode.out_file', 'inputnode.in_file')]),
        (pre,       sdc, [('outputnode.mask_b0', 'inputnode.in_mask')]),
        (inputnode, sdc, [('in_fmap_phase1', 'inputnode.in_fmap_phase1')]),
        (inputnode, sdc, [('in_fmap_phase2', 'inputnode.in_fmap_phase2')]),
        (inputnode, sdc, [('in_fmap_magnitude1', 'inputnode.in_fmap_magnitude1')]),
        (inputnode, sdc, [('in_fmap_magnitude2', 'inputnode.in_fmap_magnitude2')]),
        # Eddy-currents correction:
        (hmc, ecc, [('outputnode.out_xfms', 'inputnode.in_xfms')]),
        (pre, ecc, [('outputnode.out_bvals', 'inputnode.in_bval')]),
        (sdc, ecc, [('outputnode.out_file', 'inputnode.in_file')]),
        (pre, ecc, [('outputnode.mask_b0', 'inputnode.in_mask')]),
        # Apply all corrections:
        (pre, unwarp, [('outputnode.dwi_b0_merge', 'inputnode.in_dwi')]),
        (hmc, unwarp, [('outputnode.out_xfms', 'inputnode.in_hmc')]),
        (ecc, unwarp, [('outputnode.out_xfms', 'inputnode.in_ecc')]),
        (sdc, unwarp, [('outputnode.out_warp', 'inputnode.in_sdc')]),
        # Remove bias:
        (unwarp, bias, [('outputnode.out_file', 'inputnode.in_file')]),
#        (mask_b0,   bias, [('mask_file', 'inputnode.in_mask')]),
        # Outputnode:
        (hmc,  outputnode, [('outputnode.out_bvec', 'out_bvecs')]),
        (pre,  outputnode, [('outputnode.out_bvals', 'out_bvals')]),
        (bias, outputnode, [('outputnode.out_file', 'out_preprocessed_dwi')]),
        (bias, outputnode, [('outputnode.b0_mask','out_b0_mask')]),
        # Datasink:
        (hmc,  datasink, [('outputnode.out_xfms', 'preprocessing.head-motion-correction.@out_matrices')]),
        (pre,  datasink, [('outputnode.out_bvals', 'preprocessing.head-motion-correction.@out_bval')]),
        (hmc,  datasink, [('outputnode.out_bvec', 'preprocessing.head-motion-correction.@out_bvec')]),
        (hmc,  datasink, [('outputnode.out_file', 'preprocessing.head-motion-correction.@out_file')]),
        (sdc,  datasink, [('outputnode.out_file', 'preprocessing.susceptibility-distortion-correction.@out_file')]),
        (sdc,  datasink, [('outputnode.out_vsm', 'preprocessing.susceptibility-distortion-correction.@out_vsm')]),
        (sdc,  datasink, [('outputnode.out_warp', 'preprocessing.susceptibility-distortion-correction.@out_warp')]),
        (pre,  datasink, [('outputnode.out_bvals', 'preprocessing.@out_bvals')]),
        (hmc,  datasink, [('outputnode.out_bvec', 'preprocessing.@out_bvecs')]),
        (bias, datasink, [('outputnode.b0_mask','preprocessing.@out_b0_mask')]),
        (bias, datasink, [('outputnode.out_file', 'preprocessing.@out_preprocessed_dwi')]),
        ])

    return wf
